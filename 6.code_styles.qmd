---
title: "CodeStyle"
author: "Lev Kovalenko"
format: 
    revealjs: 
        theme: dark
        self-contained: true
        echo: true
        source: true
jupyter: "epml"
---

## Почему это важно?

:::: {.columns}

::: {.column width="50%"}
Начинающий программист
![](images/cs_june.gif){fig-align="center"}
:::

::: {.column width="50%"}
Опытный программист
![](images/cs_senior.gif){fig-align="center"}
:::
::::

::: {.notes}
Потому что датасаентисты работают с кодом. В процессе работы приходиться писать и дебажить код, изучать библиотеки, примеры использования инстурментов, а также читать и разбирать код коллег. Это все может занимать значительную долю времени. Для экономии своего времени и времени коллег (ну кому охота подня читать код?) приходиться договариваться о стиле и структуре кода и приводить код к одному виду. Это ключевой фактор, который характеризует читабельность кода.

В процессе сбора материала для презентации я набрел на исследования, в которых датчики следили за движениями глаз начинающего и опытного программистов. [Code style как стандарт разработки](https://habr.com/ru/company/manychat/blog/468953/)

Обратите внимание, чем занимается опытный программист. Он выделяет блоки кода, декомпозирует их и читает поблочно, выделяя ключевые части и анализируя их работу. Начинающий же мечется построчно, просто пытается понять, что тут вообще происходит. 

Видео довольно старое, от 2012 года, и запись была направлена на исследование процессов мозга программиста. Чуть подробнее можно почитать [тут](https://synesthesiam.github.io/pages/research.html).
:::

## Основная мотивация появления CodeStyle

- Ускорить понимания и ревью кода.
- Уменьшить стилистическое разнообразие кода.
- Уменьшить сложность кода.
- Запретить использование плохих практик.

## Читаемость кода

Есть 2 способа ускорить чтение и понимания кода:

1. Постоянно наращивать базу знаний разработчиков по тому, как может выглядеть код. 
2. Привести весь код к одному стандарту, задать тот самый code style

::: {.notes}
Конечно стоит идти по второму пути, поскольку это снизит нагрузку на разработчика, выделили следующие поинты, которые даст повышение читабельности кода:

- Если вы обеспечили историческое написание понятного кода, то, сколько бы не приходило и не уходило разработчиков, вы всегда имеете равное качество кода, что позволяет проекту динамично расти вне зависимости от его объема.
- Если ваш код написан понятно, новый специалист быстро разберется и начнет приносить пользу. Есть такое понятие, как точка самоокупаемости сотрудника. Это точка, с которой сотрудник начинает приносить только пользу. А если код написан понятно, новым сотрудникам научится читать ваш код, без необходимости детально разбираться. И чем быстрее он это сделает, тем быстрее перестанет задавать тонны вопросов остальным специалистам, отнимая у них время. А время специалистов, которые прошли точку самоокупаемости, значительно дороже для команды и компании с точки зрения потенциальной ценности приносимой продукту.
- Не нужно будет постоянно спотыкаться о чью-то оригинальность и специфическое оформление.
- Ваш мозг меньше сопротивляется, т.к. не нужно вникать в чужую стилистику. Ментальных ресурсов на чтение понятного кода нужно намного меньше.
-  Очень скоро, после прибытия в новую компанию, программист начнет делиться впечатлениями с бывшими коллегами и друзьями. И он либо скажет, что тут все круто, либо выделит негативные моменты в работе с кодом. 
- Задача программиста лежит на более низком уровне, чем будущее всей компании, но важно донести понимание, что понятность и читаемость кода сейчас влияет на динамику дальнейшей разработки.
:::

# [Pep8](https://peps.python.org/pep-0008/){preview-link="true"}

::: {.notes}
Основным инструментом датасаентиста обычно является python. Поэтому дальше будем обсуждать codestyle непосредственно этого языка. В питоне уже задан code style, описывается он в pep8.
- Структура файла (line length, indentation, blanc lines, break lines, imports, encoding, tabs or spaces)
- Разделение пробелами выражений
- Комментарии (docstrings, block and inline comments)
- Naming convention (переменные, константы, типы, функции, классы, методы)
- Аннотации к функциям и переменным
- Другие рекомендации

Но pep8 все равно оставляет некоторую свободу в форматировании, выставлении отсутпов и переносов строк. Поэтому в команде обычно приходиться создавать дополнительные договоренности.
:::

## {background-image="images/cs_my_own_codestyle.png" background-size="70%"}

::: {.notes}
Собственно действительно можно собрать свой собственный набор стилей для написания кода. И для этого есть множество удобных инстурментов, которые позволяют автоматизировать множетво проверок стиля и дополнить их написанием своих собсвенных.
:::

## AutoFormatters

![](images/cs_formatters.png){fig-align="center"}

::: {.notes}
На сегодняшний день есть несколько популярных автоформаттеров для питона. Yapf, Autopep8 и Black. Какой выбирать решайте сами.

- Yapf - google
- Autopep8 - Hideo Hattori
- Black - Python Software Foundation

В качестве инструмента форматирования согласно PEP 8 используют autopep8 (есть и другие, но этот самый популярный). Он запускается через командную строку, поддерживает множество аргументов. Но ожидать, что ваш Python-код станет повсюду единообразным не стоит, поскольку PEP 8 не дает строгих рекомендаций. Но уж лучше с ним, чем без него.

YAPF является не официальным продуктом от Google, но кодом, который, так случилось, владеет Google. YAPF основан на таком инструменте форматирования кода Си-подобных языков, как clang-format. Он берет код и форматирует его в соответствии с заданными настройками, причем отформатирует код даже в случае, если он не нарушает PEP 8. Например, вы можете задать необходимую компоновку словарей, а все остальное сделать как в Black. Эти настройки сохраняются и передаются другим программистам.

Black является наиболее строгим инструментом форматирования. С одной стороны, это помогает придерживаться одного стиля форматирования кода, с другой, некоторые правила могут вызывать внутреннее отторжение. Кроме того, в отличие от YAPF, он не поддерживает множество настроек. По факту Black имеет две перенастраиваемые опции:

- изменение допустимой длины строки (по умолчанию стоит 88),
- разрешение использования одинарных кавычек (по умолчанию разрешаются только двойные).
- Поддержка isort

Как привести код в порядок мы обсудили, теперь же поговорим о том, как отслеживать качество кода и находить отклонения от code style.
:::

## Linters {.scrollable}

|Linter|Category|Description|
|------|--------|-----------|
|[Pylint](https://www.pylint.org/)|Logical & Stylistic|Checks for errors, tries to enforce a coding standard, looks for code smells|
|[PyFlakes](https://github.com/PyCQA/pyflakes)|Logical|Analyzes programs and detects various errors|
|[Pycodestyle](https://github.com/PyCQA/pycodestyle)|Stylistic|Checks against some of the style conventions in PEP8|
|[Pydocstyle](https://github.com/PyCQA/pydocstyle)|Stylistic|Checks compliance with Python docstring conventions|
|[Bandit](https://github.com/PyCQA/bandit)|Logical|Analyzes code to find common security issues|
|[MyPy](http://mypy-lang.org/)|Logical|Checks for optionally-enforced static types|

::: {.notes}
Теперь давайте обсудим их, зачем же их так много.

Во-первых они разбиваются на две группы: Logical и Stylistic.

Первая позволяет находить, паттерны опасного кода  и потенциальное неоднозначное поведение.
Стилистический линтеринг предназначен для проверки стилистических договоренностей.

- Pylint сложный и мощный анализатор. Который умеет многое из коробки.
- PyFlake базовый flake linter который анализирует программу и ищет потенциальные ошибки
- Pycodestyle - проверка на соглашение по pep8
- Pydocstyle - проверка docstrings по соглашению
- Bandit - проверка на безопасность кода, уязвимости в используемых библиотеках и прочее
- MyPy - проверка типов на основе аннотаций

Эти инстурменты направлены на проверку соглашений по написанию кода, которые были заключены, на поиск плохих практик, ошибок. 
:::

## Анализаторы кода - [Radon](https://radon.readthedocs.io/en/latest/)

- Цикломатическая сложность
- Метрика Холстеда
- Индекс поддерживаемости кода

::: {.notes}
А как вообще команде прверить что договренности, которые она заключила помогают в достижении изначальных целей? Как проверить читабельность кода?

Для этого существуют анализаторы кода, например Radon. Он позволяет посчитать некоторые метрики:

- Цикломатическая сложность - Чем больше в коде переходов (if-else), циклов, генераторов, обработчиков исключений и логических операторов — тем больше у программы вариантов исполнения и тем сложнее удержать в голове различные состояния системы. Метрика, которая измеряет сложность кода, опираясь на количество этих операций, называется цикломатической сложностью программы. При подсчете ее с помощью радона вы получите список файлов, классов, методов и функций в вашем проекте и их индекс сложности, от очень простого до очень сложного. Индекс укажет на перегруженные логикой места, которые можно разбить на куски помельче, упростить или переписать (если есть такая возможность — алгоритм может быть очень сложным сам по себе и попытки его разбить на куски могут только ухудшить понимабельность кода).

- Метрика Холстеда - Тут считаеся количество уникальных операторов и операндов в коде и их общее количество. Полученные значения подставляются в формулы и получается набор чисел, который описывает сложность программы и количество усилий, предположительно затраченное на написание и понимание кода.

- Индекс поддерживаемости кода - Этот индекс говорит нам о том, насколько сложно будет поддерживать или редактировать кусок программы. Этот параметр рассчитывается на основе чисел, полученных из метрик, посчитанных выше.
:::

## Как это работает?
```{python}
import ast
from utils import ast_print

ast_print(ast.parse("four=4+4"))
```

::: {.notes}
Тут чуть-чуть углубимся в сам питон.
:::